package com.core.challenges.challenges._04;

public class Homework {

    /**
     * Dificultad: ⭐
     * @param a número arbitrario.
     * @return el resultado de ejecutar la función identidad.
     */
    public int identity(int a) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐
     * @param a lado de un polígono
     * @param b lado de un polígono
     * @param c lado de un polígono
     * @param d lado de un polígono
     * @return TRUE si corresponden a los lados de un cuadrado
     */
    public boolean isSquare(int a, int b, int c, int d) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     *
     * @param a número arbitrario
     * @return TRUE si es positivo
     */
    public boolean isPositive(int a) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐
     * @param a número arbitrario
     * @param b número arbitrario
     * @return El mayor estricto entre ambos números. De no conocerse, devolver -1.
     */
    public boolean biggest(int a, int b) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐
     * @param a número arbitrario
     * @return Valor absoluto del número.
     */
    public int unsigned(int a) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐
     * Postcondición: Imprimir en pantalla los números primos de la criba de Eratóstenes.
     */
    public void sieveOfEratosthenes() {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐
     * Nota histórica: La función "tirar" fue importante para buscar contraejemplos en muchas situaciones de la
     * computación moderna, para el desarrollo de lenguajes probabilísticos.
     * La idea es "tirar" un parámetro y "quedarse" con el otro. Puede ser el primero, el segundo, o el que sea,
     * y no necesariamente podrían ser números enteros.
     * @param a número arbitrario
     * @param b número arbitrario
     * @return Primer parámetro.
     */
    public int throwSecondParameter(int a, int b) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐
     * Nota histórica: La función sucesor es una de las funciones fundamentales para poder dar una definición a
     * conjuntos infinitos de números. Por ejemplo, los números naturales se pueden definir como:
     * n := 1 | succ(n). Por ejemplo: succ(succ(1)) es válido, y esto es igual a 3. El 3 es un símbolo usado para
     * representar el número 3, pero acá, succ(succ(1)) representa el 3 sin necesidad de definir su símbolo.
     * Con esto se pueden empezar a hacer diversas demostraciones a una escala muy detallada en computación.
     *
     * @param a número arbitrario
     * @return El sucesor del número.
     */
    public int successor(int a) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐
     * @param p booleano
     * @param q booleano
     * @return Valor equivalente a aplicar la compuerta XOR de la forma a XOR b.
     */
    public boolean xor(boolean p, boolean q) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐
     * @param p booleano
     * @param q booleano
     * @return Valor equivalente a aplicar la compuerta NAND de la forma a NAND b.
     */
    public boolean nAnd(boolean p, boolean q) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐
     * @param p booleano
     * @param q booleano
     * @return Valor equivalente a aplicar la compuerta NOR de la forma a NOR b.
     */
    public boolean nOr(boolean p, boolean q) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐
     *
     * Ejemplos:
     * Input: 4
     * Output: 4*3*2*1
     *
     * Input: 7
     * Output: 7*6*5*4*3*2*1
     *
     * @param n número arbitrario
     * @return factorial del número
     */
    public int factorial(int n) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐
     * Precondición: 100 > n > 0
     *
     * Ejemplos:
     * Input: 1
     * Output: "u"
     *
     * Input: 2
     * Output: "d"
     *
     * @param n número arbitrario
     * @return La primera del número.
     */
    public String firstCharacter(int n) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐
     * @param min inicio del rango
     * @param max fin del rango
     * @return Cantidad de números impares en el rango
     */
    public int totalOdds(int min, int max) {
        throw new RuntimeException("Not yet implemented");
    }

    /*
    Esta función debe calcular el doble factorial de un número natural.
    Ejemplo: 4! = 4*2, 7! = 7*5*3*1.

     */

    /**
     * Dificultad: ⭐⭐
     *
     * Ejemplos:
     * Input: 4
     * Output: 4*2
     *
     * Input: 7
     * Output: 7*5*3*1
     * @param n número arbitrario
     * @return Calcular el doble factorial del nùmero.
     */
    public int doubleFactorial(int n) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐
     * Postcondición: Imprimir en pantalla todos sus divisores
     * @param n número arbitrario
     */
    public void printDivisors(int n) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐
     * @param a número arbitrario
     * @param b número arbitrario
     * @param c número arbitrario
     * @return mayor estricto. De no existir, devolver -1.
     */
    public boolean biggest(int a, int b, int c) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐
     * Tip: Investigar sobre el calendario gregoriano.
     * @param year es un año arbitrario. Por ejemplo, 2015, 1995, 456, -100, 2023.
     * @return TRUE si el año es bisiesto.
     */
    public boolean isLeapYear(int year) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐
     * Precondición: 0 <= n <= 180.
     * Postcondición: Imprimir en pantalla el número en formato de números romanos.
     * @param n número arbitrario
     */
    public void mapsToRomanNumeral(int n) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐
     * Tip: Un número es primo de fermat si tiene la forma 2^(2^n) + 1.
     * @param a número arbitrario
     * @return TRUE si el número es primo de Fermat.
     */
    public boolean fermatNumber(int a) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐
     * Ejemplos:
     * Input: 100
     * Output: 1
     *
     * Input: 456
     * Output: 654
     *
     * Input: 1000000009
     * Output: -1
     *
     * Tip: No siempre es posible con este tipo de dato (int). En el caso de no poderse, devolver -1.
     * @param n número arbitrario
     * @return el mismo número dado vuelta.
     */
    public int reverse(int n) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐
     * @param p booleano
     * @param q booleano
     * @return p => q
     */
    public boolean then(boolean p, boolean q) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐
     * Ejemplos:
     * Input: 0
     * Output: 1
     *
     * Input: 4785
     * Output: 4
     *
     * @param a número arbitrario
     * @return cantidad de dígitos del número.
     */
    public int digits(int a) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐
     * Postcondición: Pintar en pantalla los números primos en el rango especificado.
     * @param min inicio del rango
     * @param max fin del rango
     */
    public void getPrimes(int min, int max) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐
     * Postcondición: Imprimir en pantalla todas las ternas pitagóricas (a, b, c), tal que 0 < a,b,c < 100.
     */
    public void pythagoreanTriple() {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐
     * @param year año de la fecha.
     * @param month mes de la fecha.
     * @param day día del mes de la fecha.
     * @return TRUE si la fecha es una fecha gregoriana válida.
     */
    public boolean validDate(int year, int month, int day) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐
     * Un número cuadrado perfecto es un número entero que se obtiene de elevar al cuadrado otro número entero.
     *
     * Ejemplo:
     * Input: 8
     * Output: false
     *
     * Input: 9
     * Output: true
     *
     * @param n número arbitrario.
     * @return TRUE si el número es un cuadrado perfecto.
     */
    public boolean isPerfectSquare(int n) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐
     * Los números vampiros son números que al multiplicarlos, su producto tiene de dígitos los mismos dígitos de los
     * factores. No necesariamente están en la misma posición. Ejemplo: 21 x 60 = 1.260, entonces 21 y 60 son vampiros.
     * @param a factor arbitrario
     * @param b factor arbitrario
     * @return TRUE si son una pareja de números vampiros.
     */
    public boolean vampireNumber(int a, int b) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐
     * Dos números se consideran amigos, si los divisores del primer número suman el segundo, y viceversa.
     * @param a número arbitrario
     * @param b número arbitrario
     * @return TRUE si son números amigos.
     */
    public boolean areAmicableNumbers(int a, int b) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐
     * Si tenemos la función f(a) = a + 1, y g(b) = b + 2, entonces f(g(b)) = b + 2 + 1, y por otro lado,
     * g(f(a)) = a + 1 + 2. Estas funciones representan lo mismo.
     * Postcondición: Pensar un ejemplo en computación, donde esta conmutatividad no será verdadera y desarrollarlo.
     */
    public void noCommutativityComposition() {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐
     * Un número es abuntante si la suma de sus divisores es más grande que el número en sí, y deficiente si no llega.
     * Es perfecto si sus divisores suman el mismo número. Ejemplo: Los divisores de 10 son 1, 2 y 5, sumados da 8
     * que es menor a 10, por ende es definiciente. Los divisores de 6 son 1, 2 y 3, que suman 6.
     * Entonces 6 es perfecto.
     * @param n número arbitrario.
     * @return -1 si es un número deficiente, 0 si es perfecto y 1 si es abundante.
     */
    public int isPerfect(int n) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐
     * Un número es narcisista si cada dígito elevado a la cantidad de dígitos del número, sumados, da el mismo número.
     * Ejemplo: 1^3 + 5^3 + 3^3 = 153, entonces 153 es narcisista. Lo mismo va a suceder con números de un solo dígito.
     * @param n número arbitrario.
     * @return TRUE si el número es narcisista.
     */
    public boolean isNarcissistic(int n) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐
     * Precondición: El inicio del rango se puede considerar 0.
     * Postcondición: Imprimir en pantalla todos los primos gemelos del rango.
     * @param max final del rango.
     */
    public void printTwinPrimeNumbers(int max) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐
     * Postcondición: Usando prints, dibujar una pirámide de asteríscos de tamaño n.
     * Ejemplo: Si n es 4, entonces se debe imprimir en pantalla:
     *     *
     *     **
     *     ***
     *     ****
     * @param n tamaño de la pirámide.
     */
    public boolean triangle(int n) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐
     * Por ejemplo, en el rango 10 a 19, se devuelve el 1.
     * @param min inicio del rango.
     * @param max fin del rango.
     * @return dígito más común en el rango.
     */
    public char frequentDigit(int min, int max) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐
     * @param n número arbitrario, con n > 0.
     * @return n ^ n
     */
    public int nToN(int n) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐
     * @param a número arbitrario.
     * @return dígito más chico del número.
     */
    public boolean min(int a) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐
     * @param a número arbitrario.
     * @return dígito más grande del número.
     */
    public boolean max(int a) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐⭐
     * @param a lado de un polígono.
     * @param b lado de un polígono.
     * @param c lado de un polígono.
     * @return TRUE si es posible armar un triángulo con estos lados.
     */
    public boolean isTriangle(int a, int b, int c) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐⭐
     * Precondición: No será válido utilizar operaciones no numéricas.
     * @param a número arbitrario.
     * @return TRUE si el número es capicúa.
     */
    public boolean isPalindromic(int a) {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐⭐
     * Postcondición: Mostrar que la conjetura de Golback es verdad hasta n = 1000.
     */
    public void goldbachConjecture() {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐⭐
     * @return devuelve el número natural más pequeño que cumple que n^n es múltiplo de n.
     */
    public int minNToNModN() {
        throw new RuntimeException("Not yet implemented");
    }

    /**
     * Dificultad: ⭐⭐⭐⭐⭐
     * @param a número arbritario.
     * @return nuevo número originado de permutar los dígitos del número original, de tal forma que es el más grande
     * posible.
     */
    public boolean sort(int a) {
        throw new RuntimeException("Not yet implemented");
    }
}
